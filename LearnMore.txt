
*методы класса обжект?

public:
getClass()
hashCode()
equals(Object obj)
toString()
notify()
notifyAll()
wait()

protect:
clone()
finalize()

*методы иквалс и хешкод что за методы и зачем нужны, какой контракт там есть
equals - метод сравнения сущности объектов
HashCode - уникальное число, присваемое объекту на основе алгоритма. Используется для определения места в хеш-таблицах.

Контракты для equals()
Рефлексивность
для любого заданного значения x, выражение x.equals(x) должно возвращать true.
Заданного — имеется в виду такого, что x != null
Симметричность
для любых заданных значений x и y, x.equals(y) должно возвращать true только в том случае, когда y.equals(x) возвращает true.
Транзитивность
для любых заданных значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, x.equals(z) должно вернуть значение true.
Согласованность
для любых заданных значений x и y повторный вызов x.equals(y) будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.
Сравнение null
для любого заданного значения x вызов x.equals(null) должен возвращать false.

Контракты для HashCod()
вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения.
    Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.


*колеекции в целом
Интерфейс коллекции - некая группа объектов для управлениям элементами
Наследуется от класа - Iterable
От коллекйия наследуются интерфейсы списков
set, map и list
set - не структурированный набор элементов
list - структурированный набор элементов
map - структурированный набор элементов, каждый элемент представляет собой пару ключ-значение


*хеш мапы - как работате внутри
При добавлении нового значения:
1. Проверяется на null (если true, то сразу на 4-ый шаг)
2. Далее генерируется хэш на основе ключа
3. Определяется позиция в массиве, куда будет помещен элемент
4. Запись в ячейку. Если хеш и ключ совпадают, то перезаписывается значение


*что если хешкод написать return 1 или return random(), что изменится в в работе хешмапы
если у всех будет 1, то будут сплошные коллизии
если речь про HashMap, то все элементы будут записываться в одну ячеку массива, и по факту это будет обычный LinkedList.
Но в отличии от Linked List, операции get будут дольше, т.к. для всех рбъектов будет вызываться метод equals()
Согласно контрактам, все объекты будут равны друг другу
если рандом, то противоположно, ни один объект не будет равен друг другу или равные объекты по хешкоду не будут равны
по значению, что так же нарушает контракты

*другие мапы. отличия от хешмапы
LinkedHahMap - сохраняет порядок добавления элементов
TreeMap - сортирует элементы по ключу

*многопточность
*зачем вообще нужна
запуск параллельных потоков программы

*какие способы запустить поток в java
Расширение от класса Thread или наследование от интерефейса Runnable.
Запускается через thread.start()
Нужно действие потокоа описывается в переопределенном методе run()

*какие проблемы возникают(рейс кондишен - гонка, дедлоки), как их решать
Рейс Кондишен - когда два потока работают с одной переменной, результат их выполнения может
перезатираться. Например, один поток увеличил значение, а второй уменьшил. В итоге значение будет
уменьшено (а должно было бы остаться не изменным).
Решение - использоваться synchronized methods\block

Дедлок - когда поток А ждет завершение потока Б, а поток Б ждет завершения потока А.
Решение - следить за архитектурой кода. Использовать средставп оптимизации мульипоточности.
(класс concurrent, например)

*volatile
Помечает перменную как общую для несколькиз потоков. Исключает возможность, когда один поток не успел выполнить
операцию, а второй поток уже использует переменную.

*тредпулы, что это зачем оно надо
Контроль за потоками. Мы можем задать сколько потоков будет одновременно работать (через класс Executor)


*спринг
*какие модкли бывают
Самый распрастраненный Spring MVC
*основные анатации и их отличия
@Component
Помечаются классы, для которых мы хотим, что бы Spring создал bean.
Можно указать id, иначе будет вззято имя класса.
@Autowired
Создает зависимости по созданным bean по анатации @Component
Объявляется над конструктором, сеттером или полем(переменной).
Работает даже с private (через рефлексию API).
Если подходящего bean нет или их несколько, то выкидывает исключение.
Что бы решить проблему с несколькими подходящими, надо добавить @Qualifier(id="bean_id")
@Value(&{property_name})
Задается над полем и присваевает ему значение из проперти файла.
@Scope("singleton\prototype")
singleton - создается только один экземпляр класса
prototype - создается новый экземпляр класса при кажом вызове
@PostConstruct
Метод, который будет выполнен после всех других
@PreDestroy
Метод, который будет выполнен первым при запуске программы


контроллеры

Классы контроллеры отвечают за получение и работу с данными, взаимодейстиве со службами, передачу обработанных данных на
визуализацию.

транзакции @Transactional как работате в спринге
что такое вообще транзации зачем они нужны, можно ли без них

бд
транзакции
способы диагностирования производительности бд(експлайн)
способоы оптимизации бд(индексмы,репликации)

инфрастурктура
ребит кафка докеры